"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/realtime/page",{

/***/ "(app-pages-browser)/./hooks/useSensorData.ts":
/*!********************************!*\
  !*** ./hooks/useSensorData.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSensorData: function() { return /* binding */ useSensorData; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n/* harmony import */ var _useSocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useSocket */ \"(app-pages-browser)/./hooks/useSocket.ts\");\n/* __next_internal_client_entry_do_not_use__ useSensorData auto */ \n\n\n/**\n * Transform API sensor reading to dashboard SensorData format\n */ function transformReading(reading) {\n    const time = new Date(reading._time);\n    var _reading_temperature, _reading_humidity, _reading_ph, _reading_methane;\n    return {\n        timestamp: time.toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n        }),\n        temperature: (_reading_temperature = reading.temperature) !== null && _reading_temperature !== void 0 ? _reading_temperature : 0,\n        humidity: (_reading_humidity = reading.humidity) !== null && _reading_humidity !== void 0 ? _reading_humidity : 0,\n        ph: (_reading_ph = reading.ph) !== null && _reading_ph !== void 0 ? _reading_ph : 0,\n        methane: (_reading_methane = reading.methane) !== null && _reading_methane !== void 0 ? _reading_methane : 0\n    };\n}\nfunction useSensorData() {\n    const [currentData, setCurrentData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dataHistory, setDataHistory] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [alerts, setAlerts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedRange, setSelectedRange] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"1h\");\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const addAlert = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((type, message)=>{\n        const newAlert = {\n            id: Math.random().toString(36).substr(2, 9),\n            type,\n            message,\n            timestamp: new Date()\n        };\n        setAlerts((prev)=>[\n                newAlert,\n                ...prev\n            ].slice(0, 5));\n    }, []);\n    const checkAlerts = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((data)=>{\n        if (data.methane > 85) {\n            addAlert(\"critical\", \"Dangerously high methane level detected!\");\n        } else if (data.temperature > 40 || data.temperature < 26) {\n            addAlert(\"warning\", \"Digester temperature outside optimal range.\");\n        }\n    }, [\n        addAlert\n    ]);\n    // Handle incoming real-time sensor data\n    const handleSensorData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((reading)=>{\n        const transformed = transformReading(reading);\n        setCurrentData(transformed);\n        setDataHistory((prev)=>{\n            const next = [\n                ...prev,\n                transformed\n            ];\n            return next.slice(-20); // Keep last 20 readings\n        });\n        checkAlerts(transformed);\n    }, [\n        checkAlerts\n    ]);\n    // Socket connection\n    const { isConnected: socketConnected } = (0,_useSocket__WEBPACK_IMPORTED_MODULE_2__.useSocket)({\n        onSensorData: handleSensorData,\n        onConnect: ()=>setIsConnected(true),\n        onDisconnect: ()=>setIsConnected(false)\n    });\n    // Fetch data function\n    const fetchData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            // Fetch latest data\n            const latestData = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchLatestData)();\n            if (latestData.length > 0) {\n                const latest = transformReading(latestData[0]);\n                setCurrentData(latest);\n            }\n            // Fetch history based on selected range\n            const apiRange = (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.rangeToApiFormat)(selectedRange);\n            const historyData = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchHistoryData)(apiRange);\n            const transformedHistory = historyData.map(transformReading);\n            setDataHistory(transformedHistory.slice(-20)); // Keep last 20 for display\n        } catch (err) {\n            console.error(\"Failed to fetch sensor data:\", err);\n            setError(err instanceof Error ? err.message : \"Failed to fetch data\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        selectedRange\n    ]);\n    // Initial fetch and refetch on range change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchData();\n    }, [\n        fetchData\n    ]);\n    // Polling fallback: fetch latest data every 5 seconds to ensure real-time updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const pollLatestData = async ()=>{\n            try {\n                const latestData = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchLatestData)();\n                if (latestData.length > 0) {\n                    const latest = transformReading(latestData[0]);\n                    setCurrentData(latest);\n                    setDataHistory((prev)=>{\n                        // Only add if different from the last entry\n                        const lastEntry = prev[prev.length - 1];\n                        if (lastEntry && lastEntry.timestamp === latest.timestamp) {\n                            return prev;\n                        }\n                        const next = [\n                            ...prev,\n                            latest\n                        ];\n                        return next.slice(-20); // Keep last 20 readings\n                    });\n                    checkAlerts(latest);\n                }\n            } catch (err) {\n                console.error(\"Polling error:\", err);\n            }\n        };\n        const intervalId = setInterval(pollLatestData, 5000); // Poll every 5 seconds\n        return ()=>clearInterval(intervalId);\n    }, [\n        checkAlerts\n    ]);\n    return {\n        currentData,\n        dataHistory,\n        alerts,\n        isLoading,\n        error,\n        isConnected: socketConnected,\n        selectedRange,\n        setSelectedRange,\n        refetch: fetchData\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVNlbnNvckRhdGEudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7bUVBRXlEO0FBQzRDO0FBQzdEO0FBZXhDOztDQUVDLEdBQ0QsU0FBU08saUJBQWlCQyxPQUFzQjtJQUM1QyxNQUFNQyxPQUFPLElBQUlDLEtBQUtGLFFBQVFHLEtBQUs7UUFHbEJILHNCQUNIQSxtQkFDTkEsYUFDS0E7SUFMYixPQUFPO1FBQ0hJLFdBQVdILEtBQUtJLGtCQUFrQixDQUFDLEVBQUUsRUFBRTtZQUFFQyxNQUFNO1lBQVdDLFFBQVE7UUFBVTtRQUM1RUMsYUFBYVIsQ0FBQUEsdUJBQUFBLFFBQVFRLFdBQVcsY0FBbkJSLGtDQUFBQSx1QkFBdUI7UUFDcENTLFVBQVVULENBQUFBLG9CQUFBQSxRQUFRUyxRQUFRLGNBQWhCVCwrQkFBQUEsb0JBQW9CO1FBQzlCVSxJQUFJVixDQUFBQSxjQUFBQSxRQUFRVSxFQUFFLGNBQVZWLHlCQUFBQSxjQUFjO1FBQ2xCVyxTQUFTWCxDQUFBQSxtQkFBQUEsUUFBUVcsT0FBTyxjQUFmWCw4QkFBQUEsbUJBQW1CO0lBQ2hDO0FBQ0o7QUFFTyxTQUFTWTtJQUNaLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHdEIsK0NBQVFBLENBQW9CO0lBQ2xFLE1BQU0sQ0FBQ3VCLGFBQWFDLGVBQWUsR0FBR3hCLCtDQUFRQSxDQUFlLEVBQUU7SUFDL0QsTUFBTSxDQUFDeUIsUUFBUUMsVUFBVSxHQUFHMUIsK0NBQVFBLENBQVUsRUFBRTtJQUNoRCxNQUFNLENBQUMyQixXQUFXQyxhQUFhLEdBQUc1QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUM2QixPQUFPQyxTQUFTLEdBQUc5QiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDK0IsZUFBZUMsaUJBQWlCLEdBQUdoQywrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNpQyxhQUFhQyxlQUFlLEdBQUdsQywrQ0FBUUEsQ0FBQztJQUUvQyxNQUFNbUMsV0FB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S0wsS0FBSyxDQUFDLENBQUMsS0FBSyx3QkFBd0I7b0JBQ3BEO29CQUNBQyxZQUFZWTtnQkFDaEI7WUFDSixFQUFFLE9BQU9LLEtBQUs7Z0JBQ1ZDLFFBQVFuQyxLQUFLLENBQUMsa0JBQWtCa0M7WUFDcEM7UUFDSjtRQUVBLE1BQU1LLGFBQWFDLFlBQVlILGdCQUFnQixPQUFPLHVCQUF1QjtRQUM3RSxPQUFPLElBQU1JLGNBQWNGO0lBQy9CLEdBQUc7UUFBQ3RCO0tBQVk7SUFFaEIsT0FBTztRQUNIekI7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUksYUFBYWtCO1FBQ2JwQjtRQUNBQztRQUNBdUMsU0FBU2hCO0lBQ2I7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VTZW5zb3JEYXRhLnRzP2I4YzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZldGNoTGF0ZXN0RGF0YSwgZmV0Y2hIaXN0b3J5RGF0YSwgcmFuZ2VUb0FwaUZvcm1hdCwgdHlwZSBTZW5zb3JSZWFkaW5nIH0gZnJvbSAnLi4vbGliL2FwaSc7XG5pbXBvcnQgeyB1c2VTb2NrZXQgfSBmcm9tICcuL3VzZVNvY2tldCc7XG5pbXBvcnQgdHlwZSB7IFNlbnNvckRhdGEsIEFsZXJ0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbnRlcmZhY2UgVXNlU2Vuc29yRGF0YVJldHVybiB7XG4gICAgY3VycmVudERhdGE6IFNlbnNvckRhdGEgfCBudWxsO1xuICAgIGRhdGFIaXN0b3J5OiBTZW5zb3JEYXRhW107XG4gICAgYWxlcnRzOiBBbGVydFtdO1xuICAgIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgICBpc0Nvbm5lY3RlZDogYm9vbGVhbjtcbiAgICBzZWxlY3RlZFJhbmdlOiBzdHJpbmc7XG4gICAgc2V0U2VsZWN0ZWRSYW5nZTogKHJhbmdlOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgcmVmZXRjaDogKCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gQVBJIHNlbnNvciByZWFkaW5nIHRvIGRhc2hib2FyZCBTZW5zb3JEYXRhIGZvcm1hdFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZWFkaW5nKHJlYWRpbmc6IFNlbnNvclJlYWRpbmcpOiBTZW5zb3JEYXRhIHtcbiAgICBjb25zdCB0aW1lID0gbmV3IERhdGUocmVhZGluZy5fdGltZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZXN0YW1wOiB0aW1lLnRvTG9jYWxlVGltZVN0cmluZyhbXSwgeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pLFxuICAgICAgICB0ZW1wZXJhdHVyZTogcmVhZGluZy50ZW1wZXJhdHVyZSA/PyAwLFxuICAgICAgICBodW1pZGl0eTogcmVhZGluZy5odW1pZGl0eSA/PyAwLFxuICAgICAgICBwaDogcmVhZGluZy5waCA/PyAwLFxuICAgICAgICBtZXRoYW5lOiByZWFkaW5nLm1ldGhhbmUgPz8gMCxcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2Vuc29yRGF0YSgpOiBVc2VTZW5zb3JEYXRhUmV0dXJuIHtcbiAgICBjb25zdCBbY3VycmVudERhdGEsIHNldEN1cnJlbnREYXRhXSA9IHVzZVN0YXRlPFNlbnNvckRhdGEgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbZGF0YUhpc3RvcnksIHNldERhdGFIaXN0b3J5XSA9IHVzZVN0YXRlPFNlbnNvckRhdGFbXT4oW10pO1xuICAgIGNvbnN0IFthbGVydHMsIHNldEFsZXJ0c10gPSB1c2VTdGF0ZTxBbGVydFtdPihbXSk7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW3NlbGVjdGVkUmFuZ2UsIHNldFNlbGVjdGVkUmFuZ2VdID0gdXNlU3RhdGUoJzFoJyk7XG4gICAgY29uc3QgW2lzQ29ubmVjdGVkLCBzZXRJc0Nvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBhZGRBbGVydCA9IHVzZUNhbGxiYWNrKCh0eXBlOiAnaW5mbycgfCAnd2FybmluZycgfCAnY3JpdGljYWwnLCBtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgbmV3QWxlcnQ6IEFsZXJ0ID0ge1xuICAgICAgICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICB9O1xuICAgICAgICBzZXRBbGVydHMocHJldiA9PiBbbmV3QWxlcnQsIC4uLnByZXZdLnNsaWNlKDAsIDUpKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjaGVja0FsZXJ0cyA9IHVzZUNhbGxiYWNrKChkYXRhOiBTZW5zb3JEYXRhKSA9PiB7XG4gICAgICAgIGlmIChkYXRhLm1ldGhhbmUgPiA4NSkge1xuICAgICAgICAgICAgYWRkQWxlcnQoJ2NyaXRpY2FsJywgJ0Rhbmdlcm91c2x5IGhpZ2ggbWV0aGFuZSBsZXZlbCBkZXRlY3RlZCEnKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnRlbXBlcmF0dXJlID4gNDAgfHwgZGF0YS50ZW1wZXJhdHVyZSA8IDI2KSB7XG4gICAgICAgICAgICBhZGRBbGVydCgnd2FybmluZycsICdEaWdlc3RlciB0ZW1wZXJhdHVyZSBvdXRzaWRlIG9wdGltYWwgcmFuZ2UuJyk7XG4gICAgICAgIH1cbiAgICB9LCBbYWRkQWxlcnRdKTtcblxuICAgIC8vIEhhbmRsZSBpbmNvbWluZyByZWFsLXRpbWUgc2Vuc29yIGRhdGFcbiAgICBjb25zdCBoYW5kbGVTZW5zb3JEYXRhID0gdXNlQ2FsbGJhY2soKHJlYWRpbmc6IFNlbnNvclJlYWRpbmcpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1SZWFkaW5nKHJlYWRpbmcpO1xuICAgICAgICBzZXRDdXJyZW50RGF0YSh0cmFuc2Zvcm1lZCk7XG4gICAgICAgIHNldERhdGFIaXN0b3J5KHByZXYgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IFsuLi5wcmV2LCB0cmFuc2Zvcm1lZF07XG4gICAgICAgICAgICByZXR1cm4gbmV4dC5zbGljZSgtMjApOyAvLyBLZWVwIGxhc3QgMjAgcmVhZGluZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrQWxlcnRzKHRyYW5zZm9ybWVkKTtcbiAgICB9LCBbY2hlY2tBbGVydHNdKTtcblxuICAgIC8vIFNvY2tldCBjb25uZWN0aW9uXG4gICAgY29uc3QgeyBpc0Nvbm5lY3RlZDogc29ja2V0Q29ubmVjdGVkIH0gPSB1c2VTb2NrZXQoe1xuICAgICAgICBvblNlbnNvckRhdGE6IGhhbmRsZVNlbnNvckRhdGEsXG4gICAgICAgIG9uQ29ubmVjdDogKCkgPT4gc2V0SXNDb25uZWN0ZWQodHJ1ZSksXG4gICAgICAgIG9uRGlzY29ubmVjdDogKCkgPT4gc2V0SXNDb25uZWN0ZWQoZmFsc2UpLFxuICAgIH0pO1xuXG4gICAgLy8gRmV0Y2ggZGF0YSBmdW5jdGlvblxuICAgIGNvbnN0IGZldGNoRGF0YSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggbGF0ZXN0IGRhdGFcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdERhdGEgPSBhd2FpdCBmZXRjaExhdGVzdERhdGEoKTtcbiAgICAgICAgICAgIGlmIChsYXRlc3REYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3QgPSB0cmFuc2Zvcm1SZWFkaW5nKGxhdGVzdERhdGFbMF0pO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnREYXRhKGxhdGVzdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZldGNoIGhpc3RvcnkgYmFzZWQgb24gc2VsZWN0ZWQgcmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IGFwaVJhbmdlID0gcmFuZ2VUb0FwaUZvcm1hdChzZWxlY3RlZFJhbmdlKTtcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcnlEYXRhID0gYXdhaXQgZmV0Y2hIaXN0b3J5RGF0YShhcGlSYW5nZSk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEhpc3RvcnkgPSBoaXN0b3J5RGF0YS5tYXAodHJhbnNmb3JtUmVhZGluZyk7XG4gICAgICAgICAgICBzZXREYXRhSGlzdG9yeSh0cmFuc2Zvcm1lZEhpc3Rvcnkuc2xpY2UoLTIwKSk7IC8vIEtlZXAgbGFzdCAyMCBmb3IgZGlzcGxheVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBzZW5zb3IgZGF0YTonLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gZmV0Y2ggZGF0YScpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtzZWxlY3RlZFJhbmdlXSk7XG5cbiAgICAvLyBJbml0aWFsIGZldGNoIGFuZCByZWZldGNoIG9uIHJhbmdlIGNoYW5nZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGZldGNoRGF0YSgpO1xuICAgIH0sIFtmZXRjaERhdGFdKTtcblxuICAgIC8vIFBvbGxpbmcgZmFsbGJhY2s6IGZldGNoIGxhdGVzdCBkYXRhIGV2ZXJ5IDUgc2Vjb25kcyB0byBlbnN1cmUgcmVhbC10aW1lIHVwZGF0ZXNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBwb2xsTGF0ZXN0RGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0RGF0YSA9IGF3YWl0IGZldGNoTGF0ZXN0RGF0YSgpO1xuICAgICAgICAgICAgICAgIGlmIChsYXRlc3REYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0ID0gdHJhbnNmb3JtUmVhZGluZyhsYXRlc3REYXRhWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudERhdGEobGF0ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RGF0YUhpc3RvcnkocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBpZiBkaWZmZXJlbnQgZnJvbSB0aGUgbGFzdCBlbnRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEVudHJ5ID0gcHJldltwcmV2Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RFbnRyeSAmJiBsYXN0RW50cnkudGltZXN0YW1wID09PSBsYXRlc3QudGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gWy4uLnByZXYsIGxhdGVzdF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5zbGljZSgtMjApOyAvLyBLZWVwIGxhc3QgMjAgcmVhZGluZ3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQWxlcnRzKGxhdGVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUG9sbGluZyBlcnJvcjonLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChwb2xsTGF0ZXN0RGF0YSwgNTAwMCk7IC8vIFBvbGwgZXZlcnkgNSBzZWNvbmRzXG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIH0sIFtjaGVja0FsZXJ0c10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudERhdGEsXG4gICAgICAgIGRhdGFIaXN0b3J5LFxuICAgICAgICBhbGVydHMsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGlzQ29ubmVjdGVkOiBzb2NrZXRDb25uZWN0ZWQsXG4gICAgICAgIHNlbGVjdGVkUmFuZ2UsXG4gICAgICAgIHNldFNlbGVjdGVkUmFuZ2UsXG4gICAgICAgIHJlZmV0Y2g6IGZldGNoRGF0YSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJmZXRjaExhdGVzdERhdGEiLCJmZXRjaEhpc3RvcnlEYXRhIiwicmFuZ2VUb0FwaUZvcm1hdCIsInVzZVNvY2tldCIsInRyYW5zZm9ybVJlYWRpbmciLCJyZWFkaW5nIiwidGltZSIsIkRhdGUiLCJfdGltZSIsInRpbWVzdGFtcCIsInRvTG9jYWxlVGltZVN0cmluZyIsImhvdXIiLCJtaW51dGUiLCJ0ZW1wZXJhdHVyZSIsImh1bWlkaXR5IiwicGgiLCJtZXRoYW5lIiwidXNlU2Vuc29yRGF0YSIsImN1cnJlbnREYXRhIiwic2V0Q3VycmVudERhdGEiLCJkYXRhSGlzdG9yeSIsInNldERhdGFIaXN0b3J5IiwiYWxlcnRzIiwic2V0QWxlcnRzIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInNlbGVjdGVkUmFuZ2UiLCJzZXRTZWxlY3RlZFJhbmdlIiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImFkZEFsZXJ0IiwidHlwZSIsIm1lc3NhZ2UiLCJuZXdBbGVydCIsImlkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwicHJldiIsInNsaWNlIiwiY2hlY2tBbGVydHMiLCJkYXRhIiwiaGFuZGxlU2Vuc29yRGF0YSIsInRyYW5zZm9ybWVkIiwibmV4dCIsInNvY2tldENvbm5lY3RlZCIsIm9uU2Vuc29yRGF0YSIsIm9uQ29ubmVjdCIsIm9uRGlzY29ubmVjdCIsImZldGNoRGF0YSIsImxhdGVzdERhdGEiLCJsZW5ndGgiLCJsYXRlc3QiLCJhcGlSYW5nZSIsImhpc3RvcnlEYXRhIiwidHJhbnNmb3JtZWRIaXN0b3J5IiwibWFwIiwiZXJyIiwiY29uc29sZSIsIkVycm9yIiwicG9sbExhdGVzdERhdGEiLCJsYXN0RW50cnkiLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwicmVmZXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSensorData.ts\n"));

/***/ })

});