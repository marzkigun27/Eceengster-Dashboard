"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useSensorData.ts":
/*!********************************!*\
  !*** ./hooks/useSensorData.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSensorData: function() { return /* binding */ useSensorData; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n/* harmony import */ var _useSocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useSocket */ \"(app-pages-browser)/./hooks/useSocket.ts\");\n/* __next_internal_client_entry_do_not_use__ useSensorData auto */ \n\n\n/**\n * Transform API sensor reading to dashboard SensorData format\n */ function transformReading(reading) {\n    const time = new Date(reading._time);\n    var _reading_gas, _ref;\n    // The gas sensor returns raw ppm values (e.g., 1098.8)\n    // Convert to percentage: assuming max gas reading of ~2000 ppm = 100%\n    // Adjust the divisor based on your sensor's actual range\n    const gasValue = (_ref = (_reading_gas = reading.gas) !== null && _reading_gas !== void 0 ? _reading_gas : reading.methane) !== null && _ref !== void 0 ? _ref : 0;\n    const methanePercent = Math.min(100, gasValue / 2000 * 100);\n    var _reading_temperature, _reading_humidity, _reading_ph;\n    return {\n        timestamp: time.toLocaleTimeString([], {\n            hour: \"2-digit\",\n            minute: \"2-digit\"\n        }),\n        temperature: (_reading_temperature = reading.temperature) !== null && _reading_temperature !== void 0 ? _reading_temperature : 0,\n        humidity: (_reading_humidity = reading.humidity) !== null && _reading_humidity !== void 0 ? _reading_humidity : 0,\n        ph: (_reading_ph = reading.ph) !== null && _reading_ph !== void 0 ? _reading_ph : 0,\n        methane: methanePercent\n    };\n}\nfunction useSensorData() {\n    const [currentData, setCurrentData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dataHistory, setDataHistory] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [alerts, setAlerts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedRange, setSelectedRange] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"1h\");\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const addAlert = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((type, message)=>{\n        const newAlert = {\n            id: Math.random().toString(36).substr(2, 9),\n            type,\n            message,\n            timestamp: new Date()\n        };\n        setAlerts((prev)=>[\n                newAlert,\n                ...prev\n            ].slice(0, 5));\n    }, []);\n    const checkAlerts = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((data)=>{\n        if (data.methane > 85) {\n            addAlert(\"critical\", \"Dangerously high methane level detected!\");\n        } else if (data.temperature > 40 || data.temperature < 26) {\n            addAlert(\"warning\", \"Digester temperature outside optimal range.\");\n        }\n    }, [\n        addAlert\n    ]);\n    // Handle incoming real-time sensor data\n    const handleSensorData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((reading)=>{\n        const transformed = transformReading(reading);\n        setCurrentData(transformed);\n        setDataHistory((prev)=>{\n            const next = [\n                ...prev,\n                transformed\n            ];\n            return next.slice(-20); // Keep last 20 readings\n        });\n        checkAlerts(transformed);\n    }, [\n        checkAlerts\n    ]);\n    // Socket connection\n    const { isConnected: socketConnected } = (0,_useSocket__WEBPACK_IMPORTED_MODULE_2__.useSocket)({\n        onSensorData: handleSensorData,\n        onConnect: ()=>setIsConnected(true),\n        onDisconnect: ()=>setIsConnected(false)\n    });\n    // Fetch data function\n    const fetchData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            // Fetch latest data\n            const latestData = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchLatestData)();\n            console.log(\"API Response (latest):\", latestData); // Debug: check actual field names\n            if (latestData.length > 0) {\n                const latest = transformReading(latestData[0]);\n                setCurrentData(latest);\n            }\n            // Fetch history based on selected range\n            const apiRange = (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.rangeToApiFormat)(selectedRange);\n            const historyData = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchHistoryData)(apiRange);\n            const transformedHistory = historyData.map(transformReading);\n            setDataHistory(transformedHistory.slice(-20)); // Keep last 20 for display\n        } catch (err) {\n            console.error(\"Failed to fetch sensor data:\", err);\n            setError(err instanceof Error ? err.message : \"Failed to fetch data\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        selectedRange\n    ]);\n    // Initial fetch and refetch on range change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchData();\n    }, [\n        fetchData\n    ]);\n    // Polling fallback: fetch latest data every 5 seconds to ensure real-time updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const pollLatestData = async ()=>{\n            try {\n                const latestData = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchLatestData)();\n                if (latestData.length > 0) {\n                    const latest = transformReading(latestData[0]);\n                    setCurrentData(latest);\n                    setDataHistory((prev)=>{\n                        // Only add if different from the last entry\n                        const lastEntry = prev[prev.length - 1];\n                        if (lastEntry && lastEntry.timestamp === latest.timestamp) {\n                            return prev;\n                        }\n                        const next = [\n                            ...prev,\n                            latest\n                        ];\n                        return next.slice(-20); // Keep last 20 readings\n                    });\n                    checkAlerts(latest);\n                }\n            } catch (err) {\n                console.error(\"Polling error:\", err);\n            }\n        };\n        const intervalId = setInterval(pollLatestData, 5000); // Poll every 5 seconds\n        return ()=>clearInterval(intervalId);\n    }, [\n        checkAlerts\n    ]);\n    return {\n        currentData,\n        dataHistory,\n        alerts,\n        isLoading,\n        error,\n        isConnected: socketConnected,\n        selectedRange,\n        setSelectedRange,\n        refetch: fetchData\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVNlbnNvckRhdGEudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7bUVBRXlEO0FBQzRDO0FBQzdEO0FBZXhDOztDQUVDLEdBQ0QsU0FBU08saUJBQWlCQyxPQUFzQjtJQUM1QyxNQUFNQyxPQUFPLElBQUlDLEtBQUtGLFFBQVFHLEtBQUs7UUFLbEJILGNBQUFBO0lBSGpCLHVEQUF1RDtJQUN2RCxzRUFBc0U7SUFDdEUseURBQXlEO0lBQ3pELE1BQU1JLFdBQVdKLENBQUFBLE9BQUFBLENBQUFBLGVBQUFBLFFBQVFLLEdBQUcsY0FBWEwsMEJBQUFBLGVBQWVBLFFBQVFNLE9BQU8sY0FBOUJOLGtCQUFBQSxPQUFrQztJQUNuRCxNQUFNTyxpQkFBaUJDLEtBQUtDLEdBQUcsQ0FBQyxLQUFLLFdBQVksT0FBUTtRQUl4Q1Qsc0JBQ0hBLG1CQUNOQTtJQUpSLE9BQU87UUFDSFUsV0FBV1QsS0FBS1Usa0JBQWtCLENBQUMsRUFBRSxFQUFFO1lBQUVDLE1BQU07WUFBV0MsUUFBUTtRQUFVO1FBQzVFQyxhQUFhZCxDQUFBQSx1QkFBQUEsUUFBUWMsV0FBVyxjQUFuQmQsa0NBQUFBLHVCQUF1QjtRQUNwQ2UsVUFBVWYsQ0FBQUEsb0JBQUFBLFFBQVFlLFFBQVEsY0FBaEJmLCtCQUFBQSxvQkFBb0I7UUFDOUJnQixJQUFJaEIsQ0FBQUEsY0FBQUEsUUFBUWdCLEVBQUUsY0FBVmhCLHlCQUFBQSxjQUFjO1FBQ2xCTSxTQUFTQztJQUNiO0FBQ0o7QUFFTyxTQUFTVTtJQUNaLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHM0IsK0NBQVFBLENBQW9CO0lBQ2xFLE1BQU0sQ0FBQzRCLGFBQWFDLGVBQWUsR0FBRzdCLCtDQUFRQSxDQUFlLEVBQUU7SUFDL0QsTUFBTSxDQUFDOEIsUUFBUUMsVUFBVSxHQUFHL0IsK0NBQVFBLENBQVUsRUFBRTtJQUNoRCxNQUFNLENBQUNnQyxXQUFXQyxhQUFhLEdBQUdqQywrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNrQyxPQUFPQyxTQUFTLEdBQUduQywrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDb0MsZUFBZUMsaUJBQWlCLEdBQUdyQywrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNzQyxhQUFhQyxlQUFlLEdBQUd2QywrQ0FBUUEsQ0FBQztJQUUvQyxNQUFNd0MsV0FBV3RDLGtEQUFXQSxDQUFDLENBQUN1QyxNQUF1Q0M7UUFDakUsTUFBTUMsV0FBa0I7WUFDcEJDLElBQUk1QixLQUFLNkIsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7WUFDekNOO1lBQ0FDO1lBQ0F4QixXQUFXLElBQUlSO1FBQ25CO1FBQ0FxQixVQUFVaUIsQ0FBQUEsT0FBUTtnQkFBQ0w7bUJBQWFLO2FBQUssQ0FBQ0MsS0FBSyxDQUFDLEdBQUc7SUFDbkQsR0FBRyxFQUFFO0lBRUwsTUFBTUMsY0FBY2hELGtEQUFXQSxDQUFDLENBQUNpRDtRQUM3QixJQUFJQSxLQUFLckMsT0FBTyxHQUFHLElBQUk7WUFDbkIwQixTQUFTLFlBQVk7UUFDekIsT0FBTyxJQUFJVyxLQUFLN0IsV0FBVyxHQUFHLE1BQU02QixLQUFLN0IsV0FBVyxHQUFHLElBQUk7WUFDdkRrQixTQUFTLFdBQVc7UUFDeEI7SUFDSixHQUFHO1FBQUNBO0tBQVM7SUFFYix3Q0FBd0M7SUFDeEMsTUFBTVksbUJBQW1CbEQsa0RBQVdBLENBQUMsQ0FBQ007UUFDbEMsTUFBTTZDLGNBQWM5QyxpQkFBaUJDO1FBQ3JDbUIsZUFBZTBCO1FBQ2Z4QixlQUFlbUIsQ0FBQUE7WUFDWCxNQUFNTSxPQUFPO21CQUFJTjtnQkFBTUs7YUFBWTtZQUNuQyxPQUFPQyxLQUFLTCxLQUFLLENBQUMsQ0FBQyxLQUFLLHdCQUF3QjtRQUNwRDtRQUNBQyxZQUFZRztJQUNoQixHQUFHO1FBQUNIO0tBQVk7SUFFaEIsb0JBQW9CO0lBQ3BCLE1BQU0sRUFBRVosYUFBYWlCLGVBQWUsRUFBRSxHQUFHakQscURBQVNBLENBQUM7UUFDL0NrRCxjQUFjSjtRQUNkSyxXQUFXLElBQU1sQixlQUFlO1FBQ2hDbUIsY0FBYyxJQUFNbkIsZUFBZTtJQUN2QztJQUVBLHNCQUFzQjtJQUN0QixNQUFNb0IsWUFBWXpELGtEQUFXQSxDQUFDO1FBQzFCK0IsYUFBYTtRQUNiRSxTQUFTO1FBRVQsSUFBSTtZQUNBLG9CQUFvQjtZQUNwQixNQUFNeUIsYUFBYSxNQUFNekQseURBQWVBO1lBQ3hDMEQsUUFBUUMsR0FBRyxDQUFDLDBCQUEwQkYsYUFBYSxrQ0FBa0M7WUFDckYsSUFBSUEsV0FBV0csTUFBTSxHQUFHLEdBQUc7Z0JBQ3ZCLE1BQU1DLFNBQVN6RCxpQkFBaUJxRCxVQUFVLENBQUMsRUFBRTtnQkFDN0NqQyxlQUFlcUM7WUFDbkI7WUFFQSx3Q0FBd0M7WUFDeEMsTUFBTUMsV0FBVzVELDBEQUFnQkEsQ0FBQytCO1lBQ2xDLE1BQU04QixjQUFjLE1BQU05RCwwREFBZ0JBLENBQUM2RDtZQUMzQyxNQUFNRSxxQkFBcUJELFlBQVlFLEdBQUcsQ0FBQzdEO1lBQzNDc0IsZUFBZXNDLG1CQUFtQmxCLEtBQUssQ0FBQyxDQUFDLE1BQU0sMkJBQTJCO1FBQzlFLEVBQUUsT0FBT29CLEtBQUs7WUFDVlIsUUFBUTNCLEtBQUssQ0FBQyxnQ0FBZ0NtQztZQUM5Q2xDLFNBQVNrQyxlQUFlQyxRQUFRRCxJQUFJM0IsT0FBTyxHQUFHO1FBQ2xELFNBQVU7WUFDTlQsYUFBYTtRQUNqQjtJQUNKLEdBQUc7UUFBQ0c7S0FBYztJQUVsQiw0Q0FBNEM7SUFDNUNuQyxnREFBU0EsQ0FBQztRQUNOMEQ7SUFDSixHQUFHO1FBQUNBO0tBQVU7SUFFZCxrRkFBa0Y7SUFDbEYxRCxnREFBU0EsQ0FBQztRQUNOLE1BQU1zRSxpQkFBaUI7WUFDbkIsSUFBSTtnQkFDQSxNQUFNWCxhQUFhLE1BQU16RCx5REFBZUE7Z0JBQ3hDLElBQUl5RCxXQUFXRyxNQUFNLEdBQUcsR0FBRztvQkFDdkIsTUFBTUMsU0FBU3pELGlCQUFpQnFELFVBQVUsQ0FBQyxFQUFFO29CQUM3Q2pDLGVBQWVxQztvQkFDZm5DLGVBQWVtQixDQUFBQTt3QkFDWCw0Q0FBNEM7d0JBQzVDLE1BQU13QixZQUFZeEIsSUFBSSxDQUFDQSxLQUFLZSxNQUFNLEdBQUcsRUFBRTt3QkFDdkMsSUFBSVMsYUFBYUEsVUFBVXRELFNBQVMsS0FBSzhDLE9BQU85QyxTQUFTLEVBQUU7NEJBQ3ZELE9BQU84Qjt3QkFDWDt3QkFDQSxNQUFNTSxPQUFPOytCQUFJTjs0QkFBTWdCO3lCQUFPO3dCQUM5QixPQUFPVixLQUFLTCxLQUFLLENBQUMsQ0FBQyxLQUFLLHdCQUF3QjtvQkFDcEQ7b0JBQ0FDLFlBQVljO2dCQUNoQjtZQUNKLEVBQUUsT0FBT0ssS0FBSztnQkFDVlIsUUFBUTNCLEtBQUssQ0FBQyxrQkFBa0JtQztZQUNwQztRQUNKO1FBRUEsTUFBTUksYUFBYUMsWUFBWUgsZ0JBQWdCLE9BQU8sdUJBQXVCO1FBQzdFLE9BQU8sSUFBTUksY0FBY0Y7SUFDL0IsR0FBRztRQUFDdkI7S0FBWTtJQUVoQixPQUFPO1FBQ0h4QjtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBSSxhQUFhaUI7UUFDYm5CO1FBQ0FDO1FBQ0F1QyxTQUFTakI7SUFDYjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZVNlbnNvckRhdGEudHM/YjhjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmV0Y2hMYXRlc3REYXRhLCBmZXRjaEhpc3RvcnlEYXRhLCByYW5nZVRvQXBpRm9ybWF0LCB0eXBlIFNlbnNvclJlYWRpbmcgfSBmcm9tICcuLi9saWIvYXBpJztcbmltcG9ydCB7IHVzZVNvY2tldCB9IGZyb20gJy4vdXNlU29ja2V0JztcbmltcG9ydCB0eXBlIHsgU2Vuc29yRGF0YSwgQWxlcnQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBVc2VTZW5zb3JEYXRhUmV0dXJuIHtcbiAgICBjdXJyZW50RGF0YTogU2Vuc29yRGF0YSB8IG51bGw7XG4gICAgZGF0YUhpc3Rvcnk6IFNlbnNvckRhdGFbXTtcbiAgICBhbGVydHM6IEFsZXJ0W107XG4gICAgaXNMb2FkaW5nOiBib29sZWFuO1xuICAgIGVycm9yOiBzdHJpbmcgfCBudWxsO1xuICAgIGlzQ29ubmVjdGVkOiBib29sZWFuO1xuICAgIHNlbGVjdGVkUmFuZ2U6IHN0cmluZztcbiAgICBzZXRTZWxlY3RlZFJhbmdlOiAocmFuZ2U6IHN0cmluZykgPT4gdm9pZDtcbiAgICByZWZldGNoOiAoKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBBUEkgc2Vuc29yIHJlYWRpbmcgdG8gZGFzaGJvYXJkIFNlbnNvckRhdGEgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVJlYWRpbmcocmVhZGluZzogU2Vuc29yUmVhZGluZyk6IFNlbnNvckRhdGEge1xuICAgIGNvbnN0IHRpbWUgPSBuZXcgRGF0ZShyZWFkaW5nLl90aW1lKTtcblxuICAgIC8vIFRoZSBnYXMgc2Vuc29yIHJldHVybnMgcmF3IHBwbSB2YWx1ZXMgKGUuZy4sIDEwOTguOClcbiAgICAvLyBDb252ZXJ0IHRvIHBlcmNlbnRhZ2U6IGFzc3VtaW5nIG1heCBnYXMgcmVhZGluZyBvZiB+MjAwMCBwcG0gPSAxMDAlXG4gICAgLy8gQWRqdXN0IHRoZSBkaXZpc29yIGJhc2VkIG9uIHlvdXIgc2Vuc29yJ3MgYWN0dWFsIHJhbmdlXG4gICAgY29uc3QgZ2FzVmFsdWUgPSByZWFkaW5nLmdhcyA/PyByZWFkaW5nLm1ldGhhbmUgPz8gMDtcbiAgICBjb25zdCBtZXRoYW5lUGVyY2VudCA9IE1hdGgubWluKDEwMCwgKGdhc1ZhbHVlIC8gMjAwMCkgKiAxMDApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZXN0YW1wOiB0aW1lLnRvTG9jYWxlVGltZVN0cmluZyhbXSwgeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pLFxuICAgICAgICB0ZW1wZXJhdHVyZTogcmVhZGluZy50ZW1wZXJhdHVyZSA/PyAwLFxuICAgICAgICBodW1pZGl0eTogcmVhZGluZy5odW1pZGl0eSA/PyAwLFxuICAgICAgICBwaDogcmVhZGluZy5waCA/PyAwLFxuICAgICAgICBtZXRoYW5lOiBtZXRoYW5lUGVyY2VudCxcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2Vuc29yRGF0YSgpOiBVc2VTZW5zb3JEYXRhUmV0dXJuIHtcbiAgICBjb25zdCBbY3VycmVudERhdGEsIHNldEN1cnJlbnREYXRhXSA9IHVzZVN0YXRlPFNlbnNvckRhdGEgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbZGF0YUhpc3RvcnksIHNldERhdGFIaXN0b3J5XSA9IHVzZVN0YXRlPFNlbnNvckRhdGFbXT4oW10pO1xuICAgIGNvbnN0IFthbGVydHMsIHNldEFsZXJ0c10gPSB1c2VTdGF0ZTxBbGVydFtdPihbXSk7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW3NlbGVjdGVkUmFuZ2UsIHNldFNlbGVjdGVkUmFuZ2VdID0gdXNlU3RhdGUoJzFoJyk7XG4gICAgY29uc3QgW2lzQ29ubmVjdGVkLCBzZXRJc0Nvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBhZGRBbGVydCA9IHVzZUNhbGxiYWNrKCh0eXBlOiAnaW5mbycgfCAnd2FybmluZycgfCAnY3JpdGljYWwnLCBtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgbmV3QWxlcnQ6IEFsZXJ0ID0ge1xuICAgICAgICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICB9O1xuICAgICAgICBzZXRBbGVydHMocHJldiA9PiBbbmV3QWxlcnQsIC4uLnByZXZdLnNsaWNlKDAsIDUpKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjaGVja0FsZXJ0cyA9IHVzZUNhbGxiYWNrKChkYXRhOiBTZW5zb3JEYXRhKSA9PiB7XG4gICAgICAgIGlmIChkYXRhLm1ldGhhbmUgPiA4NSkge1xuICAgICAgICAgICAgYWRkQWxlcnQoJ2NyaXRpY2FsJywgJ0Rhbmdlcm91c2x5IGhpZ2ggbWV0aGFuZSBsZXZlbCBkZXRlY3RlZCEnKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnRlbXBlcmF0dXJlID4gNDAgfHwgZGF0YS50ZW1wZXJhdHVyZSA8IDI2KSB7XG4gICAgICAgICAgICBhZGRBbGVydCgnd2FybmluZycsICdEaWdlc3RlciB0ZW1wZXJhdHVyZSBvdXRzaWRlIG9wdGltYWwgcmFuZ2UuJyk7XG4gICAgICAgIH1cbiAgICB9LCBbYWRkQWxlcnRdKTtcblxuICAgIC8vIEhhbmRsZSBpbmNvbWluZyByZWFsLXRpbWUgc2Vuc29yIGRhdGFcbiAgICBjb25zdCBoYW5kbGVTZW5zb3JEYXRhID0gdXNlQ2FsbGJhY2soKHJlYWRpbmc6IFNlbnNvclJlYWRpbmcpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1SZWFkaW5nKHJlYWRpbmcpO1xuICAgICAgICBzZXRDdXJyZW50RGF0YSh0cmFuc2Zvcm1lZCk7XG4gICAgICAgIHNldERhdGFIaXN0b3J5KHByZXYgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IFsuLi5wcmV2LCB0cmFuc2Zvcm1lZF07XG4gICAgICAgICAgICByZXR1cm4gbmV4dC5zbGljZSgtMjApOyAvLyBLZWVwIGxhc3QgMjAgcmVhZGluZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrQWxlcnRzKHRyYW5zZm9ybWVkKTtcbiAgICB9LCBbY2hlY2tBbGVydHNdKTtcblxuICAgIC8vIFNvY2tldCBjb25uZWN0aW9uXG4gICAgY29uc3QgeyBpc0Nvbm5lY3RlZDogc29ja2V0Q29ubmVjdGVkIH0gPSB1c2VTb2NrZXQoe1xuICAgICAgICBvblNlbnNvckRhdGE6IGhhbmRsZVNlbnNvckRhdGEsXG4gICAgICAgIG9uQ29ubmVjdDogKCkgPT4gc2V0SXNDb25uZWN0ZWQodHJ1ZSksXG4gICAgICAgIG9uRGlzY29ubmVjdDogKCkgPT4gc2V0SXNDb25uZWN0ZWQoZmFsc2UpLFxuICAgIH0pO1xuXG4gICAgLy8gRmV0Y2ggZGF0YSBmdW5jdGlvblxuICAgIGNvbnN0IGZldGNoRGF0YSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggbGF0ZXN0IGRhdGFcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdERhdGEgPSBhd2FpdCBmZXRjaExhdGVzdERhdGEoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBUEkgUmVzcG9uc2UgKGxhdGVzdCk6JywgbGF0ZXN0RGF0YSk7IC8vIERlYnVnOiBjaGVjayBhY3R1YWwgZmllbGQgbmFtZXNcbiAgICAgICAgICAgIGlmIChsYXRlc3REYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3QgPSB0cmFuc2Zvcm1SZWFkaW5nKGxhdGVzdERhdGFbMF0pO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnREYXRhKGxhdGVzdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZldGNoIGhpc3RvcnkgYmFzZWQgb24gc2VsZWN0ZWQgcmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IGFwaVJhbmdlID0gcmFuZ2VUb0FwaUZvcm1hdChzZWxlY3RlZFJhbmdlKTtcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcnlEYXRhID0gYXdhaXQgZmV0Y2hIaXN0b3J5RGF0YShhcGlSYW5nZSk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEhpc3RvcnkgPSBoaXN0b3J5RGF0YS5tYXAodHJhbnNmb3JtUmVhZGluZyk7XG4gICAgICAgICAgICBzZXREYXRhSGlzdG9yeSh0cmFuc2Zvcm1lZEhpc3Rvcnkuc2xpY2UoLTIwKSk7IC8vIEtlZXAgbGFzdCAyMCBmb3IgZGlzcGxheVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBzZW5zb3IgZGF0YTonLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gZmV0Y2ggZGF0YScpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtzZWxlY3RlZFJhbmdlXSk7XG5cbiAgICAvLyBJbml0aWFsIGZldGNoIGFuZCByZWZldGNoIG9uIHJhbmdlIGNoYW5nZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGZldGNoRGF0YSgpO1xuICAgIH0sIFtmZXRjaERhdGFdKTtcblxuICAgIC8vIFBvbGxpbmcgZmFsbGJhY2s6IGZldGNoIGxhdGVzdCBkYXRhIGV2ZXJ5IDUgc2Vjb25kcyB0byBlbnN1cmUgcmVhbC10aW1lIHVwZGF0ZXNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBwb2xsTGF0ZXN0RGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0RGF0YSA9IGF3YWl0IGZldGNoTGF0ZXN0RGF0YSgpO1xuICAgICAgICAgICAgICAgIGlmIChsYXRlc3REYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0ID0gdHJhbnNmb3JtUmVhZGluZyhsYXRlc3REYXRhWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudERhdGEobGF0ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RGF0YUhpc3RvcnkocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBpZiBkaWZmZXJlbnQgZnJvbSB0aGUgbGFzdCBlbnRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEVudHJ5ID0gcHJldltwcmV2Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RFbnRyeSAmJiBsYXN0RW50cnkudGltZXN0YW1wID09PSBsYXRlc3QudGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gWy4uLnByZXYsIGxhdGVzdF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5zbGljZSgtMjApOyAvLyBLZWVwIGxhc3QgMjAgcmVhZGluZ3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQWxlcnRzKGxhdGVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUG9sbGluZyBlcnJvcjonLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChwb2xsTGF0ZXN0RGF0YSwgNTAwMCk7IC8vIFBvbGwgZXZlcnkgNSBzZWNvbmRzXG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIH0sIFtjaGVja0FsZXJ0c10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudERhdGEsXG4gICAgICAgIGRhdGFIaXN0b3J5LFxuICAgICAgICBhbGVydHMsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGlzQ29ubmVjdGVkOiBzb2NrZXRDb25uZWN0ZWQsXG4gICAgICAgIHNlbGVjdGVkUmFuZ2UsXG4gICAgICAgIHNldFNlbGVjdGVkUmFuZ2UsXG4gICAgICAgIHJlZmV0Y2g6IGZldGNoRGF0YSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJmZXRjaExhdGVzdERhdGEiLCJmZXRjaEhpc3RvcnlEYXRhIiwicmFuZ2VUb0FwaUZvcm1hdCIsInVzZVNvY2tldCIsInRyYW5zZm9ybVJlYWRpbmciLCJyZWFkaW5nIiwidGltZSIsIkRhdGUiLCJfdGltZSIsImdhc1ZhbHVlIiwiZ2FzIiwibWV0aGFuZSIsIm1ldGhhbmVQZXJjZW50IiwiTWF0aCIsIm1pbiIsInRpbWVzdGFtcCIsInRvTG9jYWxlVGltZVN0cmluZyIsImhvdXIiLCJtaW51dGUiLCJ0ZW1wZXJhdHVyZSIsImh1bWlkaXR5IiwicGgiLCJ1c2VTZW5zb3JEYXRhIiwiY3VycmVudERhdGEiLCJzZXRDdXJyZW50RGF0YSIsImRhdGFIaXN0b3J5Iiwic2V0RGF0YUhpc3RvcnkiLCJhbGVydHMiLCJzZXRBbGVydHMiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwic2VsZWN0ZWRSYW5nZSIsInNldFNlbGVjdGVkUmFuZ2UiLCJpc0Nvbm5lY3RlZCIsInNldElzQ29ubmVjdGVkIiwiYWRkQWxlcnQiLCJ0eXBlIiwibWVzc2FnZSIsIm5ld0FsZXJ0IiwiaWQiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInByZXYiLCJzbGljZSIsImNoZWNrQWxlcnRzIiwiZGF0YSIsImhhbmRsZVNlbnNvckRhdGEiLCJ0cmFuc2Zvcm1lZCIsIm5leHQiLCJzb2NrZXRDb25uZWN0ZWQiLCJvblNlbnNvckRhdGEiLCJvbkNvbm5lY3QiLCJvbkRpc2Nvbm5lY3QiLCJmZXRjaERhdGEiLCJsYXRlc3REYXRhIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImxhdGVzdCIsImFwaVJhbmdlIiwiaGlzdG9yeURhdGEiLCJ0cmFuc2Zvcm1lZEhpc3RvcnkiLCJtYXAiLCJlcnIiLCJFcnJvciIsInBvbGxMYXRlc3REYXRhIiwibGFzdEVudHJ5IiwiaW50ZXJ2YWxJZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInJlZmV0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSensorData.ts\n"));

/***/ })

});